矩阵连乘
a.	给出一个三个矩阵连乘的例子。分别用（A1A2）A3、A1(A2A3)计算时，他们的乘法次数至少相差1000倍。

假设：A1(5000*100)、A2（100*100000）、A3（100000*3）
证明：有两种加括号的方法：
1、（A1A2）A3
2、A1（A2A3）
方法一：5000*100*100000+5000*100000*3=51500000000
方法二：100*100000*3+5000*100*3=31500000
乘法次数相差的倍数为：51500000000/31500000=1635>1000

所以：A1(5000*100)、A2（100*100000）、A3（100000*3）

 
b.	有多少种不同的方法来计算n个矩阵的连乘乘积？

设有p[n]种不同的方法来计算连乘乘积。
第k个和第k+1个矩阵之间将原矩阵分为两个矩阵序列，k=1,2,3,...,n-1
对这两个矩阵序列加完全括号，最后对所得的结果加括号。有如下公式：p[n]=∑p(k)p(n-k),当n=1时，p[n]=1
 
c.	设计一个求n个矩阵乘法最优次数的动态规划算法。
#include <stdio.h>
#define MAX 10000
int p[MAX+1]; 
int m[MAX][MAX];//矩阵连乘的最优解解 
int s[MAX][MAX];//对应m[i][j]的断开位置k记为s[i][j] 
int n;//矩阵的个数 
void juzhen(){
for (int i = 1; i <= n; i++)
    m[i][i] = 0; //当i=j时，证明只有一个矩阵，不涉及相乘问题，所以乘积为0  
for(int z=2; z<=n; z++) //当计算矩阵的长度大于等于2时,可以进行矩阵连乘  
	{
		for(int i=1; i<=n-z+1; i++)//n-z+1为最后一个z的前边界  
		{
			int j = i+z-1;//计算前边界为z，长为z的的后边界  
			m[i][j] = m[i+1][j] + p[i-1]*p[i]*p[j];  
//将ij划分为A(i) * ( A[i+1:j] ) 
			s[i][j] = i;
			for(int k=i+1; k<j; k++)
			{
				//将ij划分为( A[i:k] )* (A[k+1:j])   
                int t = m[i][k] + m[k+1][j] + p[i-1]*p[k]*p[j];//i<j 
                if (t < m[i][j])
                 {
                      m[i][j] = t;
                      s[i][j] = k;
                 }
            }
        }
    }
    	
}

void cixu(int i, int j)
{//矩阵的计算次序为
if(i==j)   //i=j证明只有一个矩阵 
printf("A%d",i);
else{
printf("(");
cixu(i,s[i][j]); 
cixu(s[i][j]+1,j);
printf(")");
}
}
int main(){
int i;
printf("请输入矩阵相乘的矩阵个数；\n");
scanf("%d",&n);
printf("请依次输入相邻矩阵的行数和列数：\n") ;
for(i=0;i<n+1;i++)
{
scanf("%d",&p[i]);
}
juzhen();
printf("矩阵连乘最小次数为:\n%d\n",m[1][n]);
printf("矩阵的计算次序为：\n");
cixu(1,n);
printf("\n");
return 0;
}
